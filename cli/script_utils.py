import core.fasta as core
from core.transformations_abstract import (SequenceListTransformer, Reverse, 
                                      Complement, DuplicatedIdentifiersRemover, 
                                      DuplicatedIdentifiersRenamer)

def script_transforms(input, output, *transformations):
    '''Manages script transformations in transformer scripts.'''

    # Cargar o ficheiro de entrada
    input_fasta = core.fastaProcessorIO.from_file(input)

    list_of_transformations = list()

    '''Instantiate transformer objects and update list of transformations based on given args
    All scripts take one single arg except for multiple_transformations, and 
    the design with a for loop and match stems from the design constraints that poses'''
    for transformation in transformations:
        match transformation:
            case None:
                continue
            case 'rename':
                list_of_transformations.append(DuplicatedIdentifiersRenamer())
            case 'remove':
                list_of_transformations.append(DuplicatedIdentifiersRemover())
            case 'reverse':
                list_of_transformations.append(Reverse())
            case 'complement':
                list_of_transformations.append(Complement())
            case 'reverse_complement':
                list_of_transformations.extend([Reverse(), Complement()])

    '''Instantiate to apply all trasformations once the list has been defined
    The .apply_transformations method returns the new list without storing it in the object,
    but the initial transformations remain stored.'''
    transformer_object = SequenceListTransformer(list_of_transformations)
    new_fasta = transformer_object.apply_transformations(
        transformer_object.transf_list, input_fasta.sequenceObjects)
    
    # .writeFastaFile calls to self.sequenceobjects, so a fastaProcessorIO must be instantiated 
    to_output = core.fastaProcessorIO(new_fasta)
    
    # Write the sequences list to the output file.
    to_output.writeFastaFile(output)

    return to_output


class ScriptErrorManager:
    '''Stores the required and optional arguments of a script and allows error managing.

    Arguments with a limited set of special values can be included in ``specialValueMap`` as
    key-tuple pairs.
    For example ``{'mode':('remove','replace')}`` will be interpreted as the argument 
    `mode` with it's allowed values being `remove` and `replace`.\n
    Methods expect the use of the module `sys` and of the ``parseArgs()`` function in the ``argsparser`` 
    module, passing the dict generated by ``parseArgs(sys.argv[1:])``.
    All script check methods return ``exit(1)`` if they fail, so ``$?`` and ``$LASTEXITCODE`` will output 1.'''

    def __init__(self, reqArgs : list, optArgs : list, specialValueMap: dict):
        self.reqArgs = reqArgs
        self.optArgs = optArgs
        self.specialValueMap = specialValueMap
        self.argset = set(reqArgs + optArgs)

    @staticmethod
    def general_check(reqArgs : list, optArgs : list, specialValueMap: dict, script_args : dict):
        script_to_check = ScriptErrorManager(reqArgs, optArgs, specialValueMap)
        script_to_check.required_arg_num_check(script_args)
        script_to_check.validate_args(script_args)
        script_to_check.validate_values(script_args)
        
    def validate_values(self, script_args : dict):
        '''Checks for unvalid values for an argument in a script.'''

        for arg in self.specialValueMap.keys():
            if arg in script_args.keys():
                if script_args[arg] not in self.specialValueMap[arg]:
                    raise ValueError(f'Found non-admitted value.\
                                     \nAllowed values for argument are: {self.specialValueMap[arg]}')

    def validate_args(self, script_args : dict):
        '''Checks for unvalid arguments in a script.'''

        assert set(script_args).issubset(self.argset), f'Las palabras del Prof. Oak resuenan en tu cabeza...\n\
            ¡Cada cosa en su momento!\n\
            Argumentos válidos: {self.argset}.'

    def required_arg_num_check(self, script_args : dict):
        '''Checks for correct number of arguments in a script.'''

        num_params = len(list(script_args.keys()))
        if  num_params < len(self.reqArgs) or num_params > len(self.argset):
            missing =  set(self.reqArgs) - set(script_args)
            raise ValueError(
                f'Script calls for at least {len(self.argset)} required parameters.\
                    \nMissing  parameters: {missing}.')