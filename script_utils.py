import fasta as core
from transformations_abstract import (SequenceListTransformer, Reverse, 
                                      Complement, DuplicatedIdentifiersRemover, 
                                      DuplicatedIdentifiersRenamer)

def script_transforms(input, output, transformation):
    '''Manages script transformations in transformer scripts.'''

    # Cargar o ficheiro de entrada
    input_fasta = core.fastaProcessorIO.from_file(input)

    list_of_transformations = list()

    # Instantiate transformer objects and update list of transformations based on given args
    if transformation in ('rename', 'remove'):
        if transformation == 'rename': # DUDA esto é o mesmo que a duda de se ten sentido aplicar as transformacións de unha en unha
            transformer_renamer = DuplicatedIdentifiersRenamer()
            list_of_transformations.append(transformer_renamer)

        elif transformation == 'remove':
            transformer_remover = DuplicatedIdentifiersRemover()
            list_of_transformations.append(transformer_remover)

    elif transformation in ('reverse', 'complement'):
        if transformation == 'reverse':
            transformer_reverse = Reverse()
            list_of_transformations.append(transformer_reverse)

        elif transformation == 'complement':
            transformer_complement = Complement()
            list_of_transformations.append(transformer_complement)

    # Instantiate to apply all trasformations once the list has been defined
    # The .apply_transformations method directly returns the new list without storing it in the object
    new_fasta = SequenceListTransformer.apply_transformations(
            list_of_transformations, input_fasta.sequenceObjects)
    # .writeFastaFile calls to self.sequenceobjects, so a fastaProcessorIO must be instantiated 
    to_output = core.fastaProcessorIO(new_fasta)
    
    # Write the sequences list to the output file.
    to_output.writeFastaFile(output)

    return to_output


class ScriptErrorManager:
    '''Stores the required and optional arguments of a script and allows error managing.

    Arguments with a limited set of special values can be included in ``specialValueMap`` as
    key-tuple pairs.
    For example ``{'mode':('remove','replace')}`` will be interpreted as the argument 
    `mode` with it's allowed values being `remove` and `replace`.\n
    Methods expect the use of the module `sys` and of the ``parseArgs()`` function in the ``argsparser`` 
    module, passing the dict generated by ``parseArgs(sys.argv[1:])``.
    All script check methods return ``exit(1)`` if they fail, so ``$?`` and ``$LASTEXITCODE`` will output 1.'''

    def __init__(self, reqArgs : list, optArgs : list, specialValueMap: dict):
        self.reqArgs = reqArgs
        self.optArgs = optArgs
        self.specialValueMap = specialValueMap
        self.argset = set(reqArgs + optArgs)

    @staticmethod
    def general_check(reqArgs : list, optArgs : list, specialValueMap: dict, script_args : dict):
        script_to_check = ScriptErrorManager(reqArgs, optArgs, specialValueMap)
        script_to_check.required_arg_num_check(script_args)
        script_to_check.validate_args(script_args)
        script_to_check.validate_values(script_args)
        
    def validate_values(self, script_args : dict):
        '''Checks for unvalid values for an argument in a script.'''

        for arg in self.specialValueMap.keys():
            if arg in script_args.keys():
                if script_args[arg] not in self.specialValueMap[arg]:
                    raise ValueError(f'Found non-admitted value.\
                                     \nAllowed values for argument are: {self.specialValueMap[arg]}')

    def validate_args(self, script_args : dict):
        '''Checks for unvalid arguments in a script.'''

        assert set(script_args).issubset(self.argset), f'Las palabras del Prof. Oak resuenan en tu cabeza...\n\
            ¡Cada cosa en su momento!\n\
            Argumentos válidos: {self.argset}.'

    def required_arg_num_check(self, script_args : dict):
        '''Checks for correct number of arguments in a script.'''

        num_params = len(list(script_args.keys()))
        if  num_params < len(self.reqArgs) or num_params > len(self.argset):
            missing =  set(self.reqArgs) - set(script_args)
            raise ValueError(
                f'Script calls for at least {len(self.argset)} required parameters.\
                    \nMissing  parameters: {missing}.')